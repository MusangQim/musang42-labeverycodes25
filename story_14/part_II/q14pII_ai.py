# -------------------- Input --------------------------------------
given_input = """
#....#####.#...##.#####.##.###...#
##....#.####..####....##..####.##.
...###...#####.#.###...#..#.#..#..
##...##..#.#......###.##.##......#
..#.##..#.#.#.#...#......#######.#
.#..##...#....#..##.#..##..###..#.
#.###.###.#.#.##...#......#.##...#
##.#..##.#..#.##.#..####....#.####
.#.###.#.##....#.####..#..##....#.
#....#.#...#.....######....#..#.#.
##.#...#.##.##.###...##..###..##..
##...##.####.#####.##...#######.#.
#.##..##..#.##..#..##.#.####.#..#.
.#..#.#..#..#..#.#..#####.#.##.###
..#.#.###.###..###.#..#.###.#.###.
#.###...#.###......#.###.#...##..#
#######.#..##..#....#####.#.#..###
..#######.##...##.#...##...#..#.##
.##.#####.#.#####.###..##.##.##.#.
###..##....#.###.###.#..#..#..###.
.##.#...####...#.###..##.#.##..###
.#.####..##..#.....#.###.#####..##
#...#....###....#....#.#.#....####
....##########.###.##.....##...##.
#.#..##...#.###...##.#...##.###.##
#.#####.#...#.##.##..#.##..##.#.#.
####.####..#.#..###.###.....##.##.
.###..##....##..#.##.#..#..##.####
..##.......##....###....##....#...
..##..###....#.######.#.#...#.#...
...####.....###.##.##.#..#.#.##.#.
##.###.#.##...##.#..##..#####..#..
#.###.##.###..#...#.#..#.#.##..###
###.####....##.###.#.##.##.#..####
"""

# -------------------- Clean & convert --------------------------------
clean_input = given_input.strip()                       # buang empty line atas/bawah
floor_rows = clean_input.splitlines()                   # split tiap line
floor_notes = [[ch == "#" for ch in row] for row in floor_rows]  # True/False

# -------------------- Tile logic --------------------------------------
def decide_tiles(floor_notes, r, c):
    diagonal_touch = [
        (r - 1, c - 1),
        (r - 1, c + 1),
        (r + 1, c - 1),
        (r + 1, c + 1),
        (r, c)  # include self sama macam original code
    ]

    active_diagonals = []
    for nr, nc in diagonal_touch:
        if 0 <= nr < len(floor_notes) and 0 <= nc < len(floor_notes[nr]):
            active_diagonals.append(floor_notes[nr][nc])

    return sum(active_diagonals) % 2 == 0

# -------------------- Round logic -------------------------------------
def decide_round(floor_notes):
    return [
        [decide_tiles(floor_notes, r, c) for c in range(len(floor_notes[r]))]
        for r in range(len(floor_notes))
    ]

# -------------------- Count active tiles --------------------------------
def decide_count(floor_notes):
    return sum(map(sum, floor_notes))

# -------------------- Main loop ----------------------------------------
total_active = 0
rounds = 2025

for _ in range(rounds):
    floor_notes = decide_round(floor_notes)
    total_active += decide_count(floor_notes)

print(total_active)

